<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="blog lori webapp"><title>Javascript的继承与多态 | 这是一次旅行</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Javascript的继承与多态</h1><a id="logo" href="/.">这是一次旅行</a><p class="description">show yourself</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Javascript的继承与多态</h1><div class="post-meta">Jun 26, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><ul>
<li>本文先对es6发布之前javascript各种继承实现方式进行深入的分析比较，然后再介绍es6中对类继承的支持以及优缺点讨论。最后介绍了javascript面向对象编程中很少被涉及的“多态”，并提供了“运算符重载”的思路。本文假设你已经知道或了解了js中原型、原型链的概念。</li>
</ul>
<p>es6之前，javascript本质上不能算是一门面向对象的编程语言，因为它对于封装、继承、多态这些面向对象语言的特点并没有在语言层面上提供原生的支持。但是，它引入了原型(prototype)的概念，可以让我们以另一种方式模仿类，并通过原型链的方式实现了父类子类之间共享属性的继承以及身份确认机制。其实，面向对象的概念本质上来讲不是指某种语言特性，而是一种设计思想。如果你深谙面向对象的编程思想，即使用c这种面向过程的语言也能写出面向对象的代码（典型的代表就是windows NT 内核实现），而javascript亦是如此！正是由于javascript本身对面向对象编程没有一个语言上的支持标准，所以才有了五花八门、令人眼花缭乱的“类继承”的代码。所幸，es6增加了class、extends、static等关键字用以在语言层面支持面向对象，但是，还是有些保守！我们先列举出es6之前常见的几种继承方案，然后再来一探es6的类继承机制，最后再讨论下javascript多态。</p>
<p>##ES6之前的继承</p>
<p>###原型赋值方式</p>
<p>简而言之，就是直接将父类的一个实例赋给子类的原型。如下示例：<br>function Person(name){<br> this.name=name;<br> this.className=”person”<br>}<br>Person.prototype.getClassName=function(){<br> console.log(this.className)<br>}</p>
<p>function Man(){<br>}</p>
<p>Man.prototype=new Person();//1<br>//Man.prototype=new Person(“Davin”);//2<br>var man=new Man;</p>
<blockquote>
<p>man.getClassName()<br>“person”<br>man instanceof Person<br>true<br>如代码中1处所示，这种方法是直接new 了一个父类的实例，然后赋给子类的原型。这样也就相当于直接将父类原型中的方法属性以及挂在this上的各种方法属性全赋给了子类的原型，简单粗暴！我们再来看看man,它是Man的一个实例，因为man本身没有getClassName方法，那么就会去原型链上去找，找到的是person的getClassName。这种继承方式下，所有的子类实例会共享一个父类对象的实例，这种方案最大问题就是子类无法通过父类创建私有属性。比如每一个Person都有一个名字，我们在初始化每个Man的时候要指定一个不同名字，然后子类将这个名字传递给父类，对于每个man来说，保存在相应person中的name应该是不同的，但是这种方式根本做不到。所以，这种继承方式，实战中基本不用！</p>
<p>###调用构造函数方式</p>
</blockquote>
<p>function Person(name){<br> this.name=name;<br> this.className=”person”<br>}<br>Person.prototype.getName=function(){<br> console.log(this.name)<br>}<br>function Man(name){<br>  Person.apply(this,arguments)<br>}<br>var man1=new Man(“Davin”);<br>var man2=new Man(“Jack”);</p>
<blockquote>
<p>man1.name<br>“Davin”<br>man2.name<br>“Jack”<br>man1.getName() //1 报错<br>man1 instanceof Person<br>true<br>这里在子类的在构造函数里用子类实例的this去调用父类的构造函数，从而达到继承父类属性的效果。这样一来，每new一个子类的实例，构造函数执行完后，都会有自己的一份资源(name)。但是这种办法只能继承父类构造函数中声明的实例属性，并没有继承父类原型的属性和方法，所以就找不到getName方法，所以1处会报错。为了同时继承父类原型，从而诞生了组合继承的方式:</p>
<p>###组合继承</p>
</blockquote>
<p>function Person(name){<br> this.name=name||”default name”; //1<br> this.className=”person”<br>}<br>Person.prototype.getName=function(){<br> console.log(this.name)<br>}<br>function Man(name){<br>  Person.apply(this,arguments)<br>}<br>//继承原型<br>Man.prototype = new Person();<br>var man1=new Man(“Davin”);</p>
<blockquote>
<p>man1.name<br>“Davin”<br>man1.getName()<br>“Davin”<br>这个例子很简单，这样不仅会继承构造函数中的属性，也会复制父类原型链中的属性。但是，有个问题，Man.prototype = new Person(); 这句执行后，Man的原型如下：<br>Man.prototype<br>{name: “default name”, className: “person”}<br>也就是说Man的原型中已经有了一个name属性，而之后创建man1时传给构造的函数的name则是通过this重新定义了一个name属性，相当于只是覆盖掉了原型的name属性（原型中的name依然还在），这样很不优雅。</p>
<p>###分离组合继承</p>
</blockquote>
<p>这是目前es5中主流的继承方式，有些人起了一个吊炸天的名字“寄生组合继承”。首先说明一下，两者是一回事。分离组合继承的名字是我起的，一来感觉不装逼会好点，二来，更确切。综上所述，其实我们可以将继承分为两步：构造函数属性继承和建立子类和父类原型的链接。所谓的分离就是分两步走；组合是指同时继承子类构造函数和原型中的属性。<br>function Person(name){<br> this.name=name; //1<br> this.className=”person”<br>}<br>Person.prototype.getName=function(){<br> console.log(this.name)<br>}<br>function Man(name){<br>  Person.apply(this,arguments)<br>}<br>//注意此处<br>Man.prototype = Object.create(Person.prototype);<br>var man1=new Man(“Davin”);</p>
<blockquote>
<p>man1.name<br>“Davin”<br>man1.getName()<br>“Davin”<br>这里用到了Object.creat(obj)方法，该方法会对传入的obj对象进行浅拷贝。和上面组合继承的主要区别就是：将父类的原型复制给了子类原型。这种做法很清晰：</p>
<ol>
<li>构造函数中继承父类属性／方法，并初始化父类。</li>
<li>子类原型和父类原型建立联系。<br>还有一个问题，就是constructor属性，我们来看一下：<br>Person.prototype.constructor<br>&lt; Person(name){<br>this.name=name; //1<br>this.className=”person”<br>}<br>Man.prototype.constructor<br>&lt; Person(name){<br>this.name=name; //1<br>this.className=”person”<br>}<br>constructor是类的构造函数，我们发现，Person和Man实例的constructor指向都是Person，当然，这并不会改变instanceof的结果，但是对于需要用到construcor的场景，就会有问题。所以一般我们会加上这么一句：<br>Man.prototype.constructor = Man<br>综合来看，es5下，这种方式是首选，也是实际上最流行的。<br>行文至此，es5下的主要继承方式就介绍完了，在介绍es6继承之前，我们再往深的看，下面是独家干货，我们来看一下Neat.js中的一段简化源码（关于Neat.js，这里是传送门Neat.js官网，待会再安利）：<br>//下面为Neat源码的简化<br>－－－－－－－－－－－－－－－－－－－－－－－－－<br>function Neat(){<br>Array.call(this)<br>}<br>Neat.prototype=Object.create(Array.prototype)<br>Neat.prototype.constructor=Neat<br>－－－－－－－－－－－－－－－－－－－－－－－－－<br>//测试代码<br>var neat=new Neat;<br>neat.push(1,2,3,4)<br>neat.length //1<br>neat[4]=5<br>neat.length//2<br>neat.concat([6,7,8])//3<br>现在提问，上面分割线包起来的代码块干了件什么事？<br>对，就是定义了一个继承自数组的Neat对象！下面再来看一下下面的测试代码，先猜猜1、2、3处执行的结果分别是什么？期望的结果应该是：<br>4<br>5<br>1，2，3，4，5，6，7，8<br>而实际上却是：<br>4<br>4<br>[[1，2，3，4]，6，7，8]<br>呐尼！这不科学啊 ！why ?<br>我曾在阮一峰的一篇文章中看到的解释如下：<br>因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。<br>然而，事实并非如此！确切来说，并不是原生构造函数会忽略掉apply方法传入的this而导致属性无法绑定。要不然1处也不会输出4了。还有，neat依然可以正常调用push等方法，但继承之后原型上的方法有些也是有问题的，如neat.concat。其实可以看出，我们通过Array.call(this)也是有用的，比如length属性可用。但是，为什么会出问？根据症状，可以肯定的是最终的this肯定有问题，但具体是什么问题呢？难道是我们漏了什么地方导致有遗漏的属性没有正常初始化？或者就是浏览器初始化数组的过程比较特殊，和自定义对象不一样？首先我们看第一种可能，唯一漏掉的可能就是数组的静态方法（上面的所有继承方式都不会继承父类静态方法）。我们可以测试一下：<br>for(var i in  Array){<br>console.log(i,”xx”)<br>}<br>然而并没有一行输出，也就是说Array并没有静态方法。当然，这种方法只可以遍历可枚举的属性，如果存在不可枚举的属性呢？其实即使有，在浏览器看来也应该是数组私有的，浏览器不希望你去操作！所以第一种情况pass。那么只可能是第二种情况了，而事实，直到es6出来后，才找到了答案：<br>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。<br>请注意我加粗的文字。“所有”，这个词很微妙，不是“没有”，那么言外之意就是说es5是部分了。根据我之前的测试（在es5下），下标操作和concat在chrome下是有问题的，而大多数函数都是正常的，当然，不同浏览器可能不一样，这应该也是jQuery每次操作后的结果集以一个新的扩展后的数组的形式返回而不是本身继承数组（然后再直接返回this的）的主要原因，毕竟jQuery要兼容各种浏览器。而Neat.js面临的问题并没有这么复杂，只需把有坑的地方绕过去就行。言归正传，在es5中，像数组一样的，浏览器不让我们愉快与之玩耍的对象还有：<br>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()<br>##es6的继承方式</li>
</ol>
</blockquote>
<p>es6引入了class、extends、super、static(部分为ES2016标准)<br>class Person{<br>  //static sCount=0 //1<br>  constructor(name){<br>     this.name=name;<br>     this.sCount++;<br>  }<br>  //实例方法 //2<br>  getName(){<br>   console.log(this.name)<br>  }<br>  static sTest(){<br>    console.log(“static method test”)<br>  }<br>}</p>
<p>class Man extends Person{<br>  constructor(name){<br>    super(name)//3<br>    this.sex=”male”<br>  }<br>}<br>var man=new Man(“Davin”)<br>man.getName()<br>//man.sTest()<br>Man.sTest()//4<br>输出结果：<br>Davin<br>static method test<br>ES6明确规定，Class内部只有静态方法，没有静态属性,所以1处是有问题的，ES7有一个静态属性的提案，目前Babel转码器支持。熟悉java的可能对上面的代码感觉很亲切，几乎是自解释的。我们大概解释一下，按照代码中标号对应：</p>
<ol>
<li>constructor为构造函数，一个类有一个，相当于es5中构造函数标准化，负责一些初始化工作，如果没有定义，js vm会定义一个空的默认的构造函数。</li>
<li>实例方法，es6中可以不加”function”关键字，class内定义的所有函数都会置于该类的原型当中，所以，class本身只是一个语法糖。</li>
<li>构造函数中通过super()调用父类构造函数，如果有super方法，需要时构造函数中第一个执行的语句，this关键字在调用super之后才可用。</li>
<li>静态方法，在类定义的外部只能通过类名调用，内部可以通过this调用，并且静态函数是会被继承的。如示例中：sTest是在Person中定义的静函数，可以通过Man.sTest()直接调用。<br>##es6和es5继承的区别</li>
</ol>
<p>大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。<br>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。<br>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。<br>class A {<br>}</p>
<p>class B extends A {<br>}</p>
<p>B.<strong>proto</strong> === A // true<br>B.prototype.<strong>proto</strong> === A.prototype // true<br>上面代码中，子类B的<strong>proto</strong>属性指向父类A，子类B的prototype属性的<strong>proto</strong>属性指向父类A的prototype属性。<br>这样的结果是因为，类的继承是按照下面的模式实现的:<br>class A {<br>}</p>
<p>class B {<br>}</p>
<p>// B的实例继承A的实例<br>Object.setPrototypeOf(B.prototype, A.prototype);</p>
<p>// B继承A的静态属性<br>Object.setPrototypeOf(B, A);<br>Object.setPrototypeOf的简单实现如下：<br>Object.setPrototypeOf = function (obj, proto) {<br>  obj.<strong>proto</strong> = proto;<br>  return obj;<br>}<br>因此，就得到了上面的结果。<br>Object.setPrototypeOf(B.prototype, A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;</p>
<p>Object.setPrototypeOf(B, A);<br>// 等同于<br>B.<strong>proto</strong> = A;<br>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。<br>Object.create(A.prototype);<br>// 等同于<br>B.prototype.<strong>proto</strong> = A.prototype;</p>
<p>##es6继承的不足</p>
<ol>
<li>不支持静态属性（除函数）。</li>
<li>class中不能定义私有变量和函数。class中定义的所有函数都会被放倒原型当中，都会被子类继承，而属性都会作为实例属性挂到this上。如果子类想定义一个私有的方法或定义一个private 变量，便不能直接在class花括号内定义，这真的很不方便！<br>总结一下，和es5相比，es6在语言层面上提供了面向对象的部分支持，虽然大多数时候只是一个语法糖，但使用起来更方便，语意化更强、更直观，同时也给javascript继承提供一个标准的方式。还有很重要的一点就是－es6支持原生对象继承。<br>更多es6类继承资料请移步：MDN Classess 。<br>##多态</li>
</ol>
<p>多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。这是标准定义，在c++中实现多态的方式有虚函数、抽象类、模板，在java中更粗暴，所有函数都是“虚”的，子类都可以重写，当然java中没有虚函数的概念，我们暂且把相同签名的、子类和父类可以有不同实现的函数称之为虚函数，虚函数和模版（java中的范型）是支持多态的主要方式，因为javascript中没有模版，所以下面我们只讨论虚函数，下面先看一个例子：<br>function Person(name,age){<br> this.name=name<br> this.age=age<br>}<br>Person.prototype.toString=function(){<br> return “I am a Person, my name is “+ this.name<br>}<br>function Man(name,age){<br>  Person.apply(this,arguments)<br>}<br>Man.prototype = Object.create(Person.prototype);<br>Man.prototype.toString=function(){<br>  return “I am a Man, my name is”+this.name;<br>}<br>var person=new Person(“Neo”,19)<br>var man1=new Man(“Davin”,18)<br>var man2=new Man(“Jack”,19)</p>
<blockquote>
<p>person+””<br>“I am a Person, my name is Neo”<br>man1+””<br>“I am a Man, my name isDavin”<br>man1&lt;man2 //期望比较年龄大小 1<br>false<br>上面例子中，我们分别在子类和父类实现了toString方法，其实，在js中上述代码原理很简单，对于同名函数，子类会覆父类的，这种特性其实就是虚函数，只不过js中不区分参数个数，也不区分参数类型，只看函数名称，如果名称相同就会覆盖。现在我们来看注释1，我们期望直接用比较运算符比较两个man的大小（按年龄），怎么实现？在c++中有运算符重载，但java和js中都没有，所幸的是，js可以用一种变通的方法来实现：<br>function Person(name,age){<br> this.name=name<br> this.age=age<br>}<br>Person.prototype.valueOf=function(){<br> return this.age<br>}<br>function Man(name,age){<br>  Person.apply(this,arguments)<br>}</p>
</blockquote>
<p>Man.prototype = Object.create(Person.prototype);<br>var person=new Person(“Neo”,19)<br>var man1=new Man(“Davin”,18)<br>var man2=new Man(“Jack”,19)<br>var man3=new Man(“Joe”,19)</p>
<blockquote>
<p>man1<19 1="" 3="" 4="" true="" person="=19//2" man1<man2="" man2="=man3" 注意="" false="" 其中1、2、3、5在所有js="" vm下结果都是确定的。但是4并不一定！javascript规定，对于比较运算符，如果一个值是对象，另一个值是数字时，会先尝试调用valueof，如果valueof未指定，就会调用tostring；如果是字符串时，则先尝试调用tostring，如果没指定，则尝试valueof，如果两者都没指定，将抛出一个类型错误异常。如果比较的两个值都是对象时，则比较的时对象的引用地址，所以若是对象，只有自身＝＝＝自身，其它情况都是false。现在我们回过头来看看示例代码，前三个都是标准的行为。而第四点取决于浏览器的实现，如果严格按照标准，这应该算是chrome的一个bug="" ,但是，我们的代码使用时双等号，并非严格相等判断，所以浏览器的相等规则也会放宽。值得一提的是5，虽然person和man2="" age都是19，但是结果却是false。总结一下，chrome对相同类的实例比较策略是先会尝试转化，然后再比较大小，而对非同类实例的比较，则会直接返回false，不会做任何转化。="" 所以我的建议是：如果数字和类实例比较，永远是安全的，可以放心玩，如果是同类实例之间，可以进行非等比较，这个结果是可以保证的，不要进行相等比较，结果是不能保证的，一般相等比较，变通的做法是：="" var="" equal="!(ob1<ob2||ob1">ob2)<br>//不小于也不大于，就是等于，前提是比较操作符两边的对象要实现valueOf或toString<br>当然类似toString、valueOf的还有toJson方法，但它和重载没有什么关系，故不冗述。</19></p>
<p>##数学运算符</p>
</blockquote>
<p>让对象支持数学运算符本质上和让对象支持比较运算符原理类似，底层也都是通过valueOf、toString来转化实现。但是通过这种覆盖原始方法模拟的运算符重载有个比较大局限就是：返回值只能是数字！而c++中的运算符重载的结果可以是一个对象。试想一下，如果我们现在要实现一个复数类的加法，复数包括实部与虚部，加法要同时应用到两个部分，而相加的结果（返回值）仍然是一个复数对象，这种情况下，javascript也就无能为力了。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://lorizone0906.github.io/2017/06/26/Javascript的继承与多态/" data-id="cj6eingb20004avpghyzyl9c8" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2017/06/30/详细版用Supervisor守护你的Node-js进程/" class="pre">详细版用Supervisor守护你的Node.js进程</a><a href="/2017/06/23/流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）/" class="next">流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://lorizone0906.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/18/react入门/">react入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/移动端布局/">移动端布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/12/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/详细版用Supervisor守护你的Node-js进程/">详细版用Supervisor守护你的Node.js进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/Javascript的继承与多态/">Javascript的继承与多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/流媒体协议介绍（rtp-rtcp-rtsp-rtmp-mms-hls）/">流媒体协议介绍（rtp/rtcp/rtsp/rtmp/mms/hls）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/02/深入理解CSS过渡transition/">深入理解CSS过渡transition</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/20/js继承的几种实现方式/">js继承的几种实现方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/16/react程序模板/">react程序模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/22/iap银行信息/">iap银行信息</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">这是一次旅行.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>